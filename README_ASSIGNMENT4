####################################
## Assignment 4: Mutual Exclusion ##
####################################
implement a single global lock through mipster syscalls, e.g., a lock() and unlock() call.
implement a simple user program that demonstrates mutual exclusion, e.g, show that one process inside the critical section makes progress, processes not taking the lock make progress, and processes waiting for the lock do not make progress. Hint: you can implement the getpid system call to identify processes.
experiment with and demonstrate different interleavings: using locks, no locks, different time slices
Deadline: Nov 12, end of day

Bonus: implement basic multi-threading support

Idea: threads share one address space, processes don't
when duplicating processes, create threads instead, i.e., shared code, heap, globals, but private call stacks, private PC, private registers


Compile and Run:
================
first, compile selfie. then build count (w/ selfie) and afterwards execute count.
$ touch count
$ gcc selfie.c -o selfie
$ ./selfie -c count.c -o count
$ ./selfie -l count -m 32
$ ./selfie -l count -m 32
./selfie: loading code from input file count
./selfie: this is selfie's mipster executing count with 32MB of memory
KERNEL syscall_switch_from-to: 0->1
syscall_lock(): now locking pid 1
01234567_NEXTKERNEL syscall_switch_from-to: 0->2
 syscall_lock(). switch_from-to: 2->0
_NEXTKERNEL syscall_switch_from-to: 0->1
89:;<=>_NEXTKERNEL syscall_switch_from-to: 0->2
 syscall_lock(). switch_from-to: 2->0
_NEXTKERNEL syscall_switch_from-to: 0->1
?@ABCDEFGH_NEXTKERNEL syscall_switch_from-to: 0->2
 syscall_lock(). switch_from-to: 2->0
_NEXTKERNEL syscall_switch_from-to: 0->1
IJKLMNOPQ_NEXTKERNEL syscall_switch_from-to: 0->2
 syscall_lock(). switch_from-to: 2->0
_NEXTKERNEL syscall_switch_from-to: 0->1
RSTUVWXYreleasing lock for pid 1
 syscall_unlock(). switch_from-to: 1->0
_NEXTKERNEL syscall_switch_from-to: 0->2
syscall_lock(): now locking pid 2
_NEXTKERNEL syscall_switch_from-to: 0->1
could not release lock by pid 1. lock owned by pid 2.
00112233445_NEXTKERNEL syscall_switch_from-to: 0->2
012345678_NEXTKERNEL syscall_switch_from-to: 0->1
566778899::;_NEXTKERNEL syscall_switch_from-to: 0->2
9:;<=>?@A_NEXTKERNEL syscall_switch_from-to: 0->1
;<<==>>??@@A_NEXTKERNEL syscall_switch_from-to: 0->2
BCDEFGHIJ_NEXTKERNEL syscall_switch_from-to: 0->1
ABBCCDDEEFF_NEXTKERNEL syscall_switch_from-to: 0->2
KLMNOPQRST_NEXTKERNEL syscall_switch_from-to: 0->1
GGHHIIJJKKLL_NEXTKERNEL syscall_switch_from-to: 0->2
UVWXYreleasing lock for pid 2
 syscall_unlock(). switch_from-to: 2->0
_NEXTKERNEL syscall_switch_from-to: 0->1
MMNNO_NEXTKERNEL syscall_switch_from-to: 0->2
could not release lock by pid 2. lock owned by pid -1.
00112233445_NEXTKERNEL syscall_switch_from-to: 0->1
OPPQQRRSSTTU_NEXTKERNEL syscall_switch_from-to: 0->2
566778899::;_NEXTKERNEL syscall_switch_from-to: 0->1
UVVWWXXYYcount: exiting with error code 8
$

Interpretation and Explanation of what happened
===============================================
selfie's mipster loads 3 processes into its *memory.
the 1st process (process_id == 0) could be seen as a "kernel".
the remaining two processes are counters to demonstrate how the kernel works. they first count with just one char per iteration and afterwards use two chars (just to 'wait' for other processes to complete). there's currently no support for mipster to wait until last process exits.

all three processes are in count.c. the switch between kernel and other procesesses is handled by
count.c. a getpid() systemcall is provided for count.c to determine if process should come up as kernel or not.

please note: as soon as exit syscall is emitted the emulator stops working (second running process is not executed to the end) but resolving this issue seems not to be the goal of this assignment.

the characters 'K','E','R','N','E','L' are sent to console to indicate that kernel is running.
the kernel then switches to the next process, e.g. when switching from 0 to pid 2 it's indicated
by: 'syscall_switch_from-to: 0->2'.

please refer to ASSIGNMENT3 for further details. most of the principles are explained in the correspondending README file.

-- snip demo --
$ more count.c 
int main() {
	int i;
	int pid;

	int rr_pid;

	pid = (int)getpid();

	if (pid == 0 ) {
		rr_pid = 0;
		while (1) {

			// kernel process
			putchar('K');
			putchar('E');
			putchar('R');
			putchar('N');
			putchar('E');
			putchar('L');
			
			rr_pid = rr_pid + 1;
			if (rr_pid > 2)
				rr_pid = 1;
			sched_switch(0, rr_pid);
			putchar('_');
			putchar('N');
			putchar('E');
			putchar('X');
			putchar('T');


			//sched_yield();
		}
		exit(6);
	} else {
		// non-kernel processes
		i=48;

		lock();
		// print '0' to 'Z' (in asciitable)
		while (i<90) {
			putchar(i);
			i = i+1;
		}
		unlock();
	
		i=48;	
		// 'wait' for other processes to exit
		while (i<90) {
                        putchar(i);
                        putchar(i);
                        i = i+1;
                }
		exit(8);
	}

}
-- /snip demo --


